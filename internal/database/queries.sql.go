// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: queries.sql

package database

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const createLookupUserTable = `-- name: CreateLookupUserTable :exec
CREATE TABLE IF NOT EXISTS lookup_users (
    user_uuid uuid PRIMARY KEY NOT NULL,
    user_name varchar(16) NOT NULL
)
`

func (q *Queries) CreateLookupUserTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, createLookupUserTable)
	return err
}

const createPunishType = `-- name: CreatePunishType :exec
DO $$ BEGIN
    IF to_regtype('punishtype') IS NULL THEN
        CREATE TYPE punishtype AS enum (
            'BAN',
            'MUTE'
        );
    END IF;
END $$
`

func (q *Queries) CreatePunishType(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, createPunishType)
	return err
}

const createPunishUsersTable = `-- name: CreatePunishUsersTable :exec
CREATE TABLE IF NOT EXISTS punished_users (
    id SERIAL PRIMARY KEY,
    user_uuid uuid NOT NULL,
    reason text NOT NULL,
    done_by varchar(16) NOT NULL,
    punish_type punishtype NOT NULL,
    time_ends timestamptz NOT NULL,
    createdat timestamptz NOT NULL
)
`

func (q *Queries) CreatePunishUsersTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, createPunishUsersTable)
	return err
}

const getPlayerUUID = `-- name: GetPlayerUUID :one
SELECT user_uuid FROM lookup_users
WHERE LOWER(user_name) = LOWER($1)
`

func (q *Queries) GetPlayerUUID(ctx context.Context, lower string) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, getPlayerUUID, lower)
	var user_uuid uuid.UUID
	err := row.Scan(&user_uuid)
	return user_uuid, err
}

const isPunishedPlayer = `-- name: IsPunishedPlayer :one
SELECT id, user_uuid, reason, done_by, punish_type, time_ends, createdat FROM punished_users
WHERE user_uuid = $1 AND punish_type = $2 AND time_ends > NOW()
ORDER BY time_ends DESC LIMIT 1
`

type IsPunishedPlayerParams struct {
	UserUuid   uuid.UUID
	PunishType Punishtype
}

func (q *Queries) IsPunishedPlayer(ctx context.Context, arg IsPunishedPlayerParams) (PunishedUser, error) {
	row := q.db.QueryRowContext(ctx, isPunishedPlayer, arg.UserUuid, arg.PunishType)
	var i PunishedUser
	err := row.Scan(
		&i.ID,
		&i.UserUuid,
		&i.Reason,
		&i.DoneBy,
		&i.PunishType,
		&i.TimeEnds,
		&i.Createdat,
	)
	return i, err
}

const logIntoLookupTable = `-- name: LogIntoLookupTable :exec
INSERT INTO lookup_users (
    user_uuid, user_name
) VALUES (
    $1, $2
)
ON CONFLICT(user_uuid)
DO UPDATE SET
user_name = $2
`

type LogIntoLookupTableParams struct {
	UserUuid uuid.UUID
	UserName string
}

func (q *Queries) LogIntoLookupTable(ctx context.Context, arg LogIntoLookupTableParams) error {
	_, err := q.db.ExecContext(ctx, logIntoLookupTable, arg.UserUuid, arg.UserName)
	return err
}

const punishPlayer = `-- name: PunishPlayer :exec
INSERT INTO punished_users (
    user_uuid, reason, done_by, punish_type, time_ends, createdat
) VALUES (
    $1, $2, $3, $4, $5, NOW()
)
`

type PunishPlayerParams struct {
	UserUuid   uuid.UUID
	Reason     string
	DoneBy     string
	PunishType Punishtype
	TimeEnds   time.Time
}

func (q *Queries) PunishPlayer(ctx context.Context, arg PunishPlayerParams) error {
	_, err := q.db.ExecContext(ctx, punishPlayer,
		arg.UserUuid,
		arg.Reason,
		arg.DoneBy,
		arg.PunishType,
		arg.TimeEnds,
	)
	return err
}

const unpunishPlayer = `-- name: UnpunishPlayer :exec
UPDATE punished_users
SET time_ends = TIMESTAMP '2000-01-01 00:00:00' AT TIME ZONE 'UTC'
WHERE user_uuid = $1 AND punish_type = $2 AND time_ends > NOW()
`

type UnpunishPlayerParams struct {
	UserUuid   uuid.UUID
	PunishType Punishtype
}

func (q *Queries) UnpunishPlayer(ctx context.Context, arg UnpunishPlayerParams) error {
	_, err := q.db.ExecContext(ctx, unpunishPlayer, arg.UserUuid, arg.PunishType)
	return err
}
